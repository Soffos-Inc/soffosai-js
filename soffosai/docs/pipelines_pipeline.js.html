<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pipelines/pipeline.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pipelines/pipeline.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { apiKey } from "../../app.js";
import { Node } from "../nodes/node.js";
import {isDictObject, isNodeInput, get_serviceio_datatype, get_userinput_datatype} from "../../utils/type_classifications.js";
import {put_doc_id_to_array} from "../../utils/pipeline_preprocesses.js";


/**
 * A controller for consuming multiple Services called Nodes.
 * It validates all inputs of all Nodes before sending the first Soffos API request to ensure
 * that the Pipeline will not waste credits.
 * 
 * ** use_defaults=true means that Nodes will take input from the previous Nodes' 
 * output of the same field name prioritizing the latest Node's output. 
 * If the previous Nodes does not have it, it will take from the
 * pipeline's user_input.  Also, the Nodes will only be supplied with the required fields + default
 * of the require_one_of_choices fields.
 */
class Pipeline {
    /**
     * @param {Array.&lt;object>} nodes 
     * @param {boolean} [ use_defaults=false ]
     * @param {string} [name]
     * @param {Object} [ kwargs={} ]
     */
    constructor (nodes, use_defaults=false, name=null, kwargs={}) {
        const api_key = kwargs.apiKey;
        this.apiKey = apiKey || api_key;
        this._stages = nodes;

        this._input = {};
        this._infos = {};
        this._use_defaults = use_defaults;
        this._executionCodes = [];
        this._termination_codes = [];

        let error_messages = [];
        if (!Array.isArray(nodes)) {
            error_messages.push("stages field should be a list of Service Nodes");
        }

        let nodeNames = nodes.map(node => node.name);

        for (let node of nodes) {
            if (!(node instanceof Node) &amp;&amp; !(node instanceof Pipeline)) {
              error_messages.push(`${node} is not an instance of Node`);
            }
            let count = nodeNames.filter(n => n === node.name).length;
            if (count > 1) {
                error_messages.push(`Node name '${node.name}' is not unique.`)
            }
        }

        if (error_messages.length !== 0) {
            throw new Error(error_messages.join("\n"));
        }

        // when the pipeline is used as a Node, it needs a name
        this.name = name;
    }

    /**
     * Run the Pipeline
     * @param {object} user_input - The object that holds the input information including executionCode if needed.
     * @returns {object} The response object from soffosai.
     */
    async run(user_input) {
        // dispatch soffosai:pipeline-start event
        const pipelineStartEvent = new CustomEvent("soffosai:pipeline-start", {detail: user_input});
        window.dispatchEvent(pipelineStartEvent);
        if (!isDictObject(user_input)) {
            throw new Error("Invalid user input.");
        }
        if (!("user" in user_input)) {
            throw new ReferenceError("'user' is not defined in user_input.");
        }
        if ("text" in user_input) {
            user_input.document_text = this._input.text;
        }
        if ("question" in user_input) {
            user_input.message = user_input.question;
        }

        let stages;
        if (this._use_defaults) {
            stages = this.setDefaults(this._stages, user_input);
        } else {
            stages = this._stages;
        }
        let executionCode = user_input.executionCode;
        if (executionCode != null &amp;&amp; executionCode != undefined) {
            executionCode = this.apiKey + executionCode;
            if (this._executionCodes.includes(executionCode)) {
                return {"error": "You are still using this execution code in a current pipeline run."}
            } else {
                this._executionCodes.push(executionCode);
            }
        }

        let infos = {};
        this.validate_pipeline(stages, user_input);
        infos.user_input = user_input;
        let total_cost = 0.00;
        // Execute per stage:
        for (let i = 0; i &lt; stages.length; i++) {
            // Before running the node, check if a termination request is present:
            if (this._termination_codes.includes(executionCode)) {
                // remove the execution code from both termination codes and execution codes
                let index_from_execution = this._executionCodes.indexOf(executionCode);
                if (index_from_execution > -1 ) {
                    this._executionCodes.splice(index_from_execution, 1);
                }
                let index_from_termination = this._termination_codes.indexOf(executionCode);
                if (index_from_termination > -1) {
                    this._termination_codes.splice(index_from_termination, 1);
                }

                // return values that are ready:
                infos.total_call_cost = total_cost;
                infos.warning = "This Soffos Pipeline run is prematurely terminated."
                return infos;
            }

            let stage = stages[i];
            console.log(`Running ${stage.name}`);

            if (stage instanceof Pipeline) {
                let response = await stage.run(user_input);
                console.log(`Response ready for ${stage.name}.`);
                let pipeOutput = {};
                pipeOutput.costs = {};
                for (let key in response) {
                    if (key !== 'total_call_cost') {
                        for (let subkey in response[key]) {
                            if (subkey == 'cost') {
                                pipeOutput['costs'][key] = response[key][subkey];
                            } else if (subkey == 'charged_character_count') {
                                pipeOutput['costs'][key]['charged_character_count'] = response[key][subkey]
                            } else if (subkey == 'unit_price'){
                                pipeOutput['costs'][key]['unit_price'] = response[key][subkey]
                            } else {
                                pipeOutput[subkey] = response[key][subkey];
                            }
                        }
                    } 
                    else {
                        total_cost += response[key];
                    }
                }
                infos[stage.name] = pipeOutput;
                continue;
            }

            // dispatch nodeStartEvent
            const nodeStartEvent = new CustomEvent("soffosai:node-start", {detail: stage.source});
            window.dispatchEvent(nodeStartEvent);
            let temp_src = stage.source;
            let src = {};
            for (let [key, notation] of Object.entries(temp_src)) {
                if (isDictObject(notation)) { // value is a reference to a node or user input
                    let value = infos[notation.source][notation.field];
                    if ("pre_process" in notation) { // pre-processing needed before use of input param
                        if (notation.pre_process instanceof Function) {
                            src[key] = notation.pre_process(value);
                        } else {
                            throw new Error("pre_process value should be a function");
                        }
                    } else { // no pre-processing required
                        src[key] = value;
                    }

                } else { // notation is a constant
                    src[key] = notation;
                }                
            }
            if (!('user' in src)) {
                src.user = user_input.user;
            }
            src.apiKey = this.apiKey;

            let response = await stage.service.getResponse(src);
            if ("error" in response || !isDictObject(response)) {
                throw new Error(response);
            }

            // dispatch nodeStartEvent
            const nodeEndEvent = new CustomEvent("soffosai:node-end", {detail: response});
            window.dispatchEvent(nodeEndEvent);
            
            console.log(`Response ready for ${stage.name}`);
            infos[stage.name] = response;
            total_cost += response.cost.total_cost;
        }
        infos.total_call_cost = total_cost;

        // remove the execution code from the executionCodes in effect Array.
        const exec_code_index = this._executionCodes.indexOf(executionCode);
        if (exec_code_index > -1){
            this._executionCodes.splice(exec_code_index,1);
        }
        // dispatch soffosai:pipeline-end event
        const pipelineEndEvent = new CustomEvent("soffosai:pipeline-end", {detail: infos});
        window.dispatchEvent(pipelineEndEvent);
        
        return infos
    }


    /**
     * Validates the Pipeline construction vs the user_input before sending the first API call.
     * Throws errors when not valid.
     * @param {object} user_input 
     * @param {Node} stages 
     * @returns 
     */
    validate_pipeline(stages, user_input) {
        /*
        Before running the first service, the Pipeline will validate all nodes if they will all be
        executed successfully with the exception of database and server issues.
        */
        let error_messages = [];
    
        for(let i = 0; i &lt; stages.length; i++) {
            let stage = stages[i];

            let sub_pipe_stages
            if (stage instanceof Pipeline) {
                if (stage._use_defaults) {
                    sub_pipe_stages = stage.setDefaults(stage._stages, user_input)
                } else {
                    sub_pipe_stages = stage._stages
                }
                stage.validate_pipeline(sub_pipe_stages, user_input)
                continue;
            }   
            // stage: Node to be validated

            // check if required fields are present: already solved by making the node subclasses.

            // check if require_one_of_choices is present and not more than one
            let serviceio = stage.service._serviceio;
            if (serviceio.require_one_of_choices.length > 0) {
                const groupErrors = [];
                for (const group of serviceio.require_one_of_choices) {
                  const foundChoices = group.filter((choice) => choice in stage.source);
                  if (foundChoices.length === 0) {
                    groupErrors.push(
                      `${stage.name}: Please provide one of these values on your payload: ${group}`
                    );
                  } else if (foundChoices.length > 1) {
                    groupErrors.push(
                      `${stage.name}: Please only include one of these values: ${group}`
                    );
                  }
                }
            
                if (groupErrors.length > 0) {
                    let error_message = groupErrors.join(". ")
                  throw new TypeError(error_message);
                }
            }

            // check if datatypes are correct
            for(let [key, notation] of Object.entries(stage.source)) {
                let required_data_type = get_serviceio_datatype(stage.service._serviceio.input_structure[key]);

                if (isNodeInput(notation)) {
                    if ("pre_process" in notation) continue; // skip validation if there is a helper function

                    let reference_node_name = notation.source;
                    let required_key = notation.field;
                    if (reference_node_name == "user_input") {
                        let input_datatype = get_userinput_datatype(user_input[required_key])
                        if (required_data_type != input_datatype) {
                            error_messages.push(`On ${stage.name} node: ${required_data_type} required on user_input '${required_key}' field but ${input_datatype} is provided.`)
                        }
                    } else {
                        let source_node_found = false;
                        for (let subnode of stages) {
                            if (reference_node_name == subnode.name) {
                                source_node_found = true;
                                if (subnode instanceof Pipeline) {
                                    break;
                                }
                                let output_datatype = get_serviceio_datatype(subnode.service._serviceio.output_structure[required_key]);
                                if (output_datatype == 'null') {
                                    error_messages.push(`On ${stage.name} node: the reference node '${reference_node_name}' does not have ${required_key} key on its output.`);
                                }
                                if (required_data_type != output_datatype) {
                                    error_messages.push(`On ${stage.name} node: The input datatype required for field ${key} is ${required_data_type}. This does not match the datatype to be given by node ${subnode.name}'s ${notation.field} field which is ${output_datatype}.`);
                                }
                                break;
                            }
                        }
                        if (!source_node_found) {
                            error_messages.push(`Node '${reference_node_name}' is not found.`)
                        }
                    }
                    
                } else {
                    if (get_userinput_datatype(notation) == required_data_type) {
                        stage.service._payload[key] = notation;
                    } else {
                        error_messages.push(`On ${stage.name} node: ${key} requires ${required_data_type} but ${typeof notation} is provided.`)
                    }
                }
            }
        }
    
        if (error_messages.length != 0) {
            throw new Error(error_messages.join(","));
        }
        return true;
    }

    /**
     * Adds a node at the end of the node list/stages.
     * @param {Node} node 
     */
    add_node(node) {
        if ((node instanceof Node) || (node instanceof Pipeline)){
            this._stages.push(node);
        } else {
            throw new Error(`${node} is not a Node instance.`)
        }
    }

    /**
     * 
     * @param {Node[]} stages
     * @param {object} user_input
     * @returns 
     */
    setDefaults(stages, user_input) {
        let defaulted_stages = [];

        for (let i=0; i&lt;stages.length; i++) {
            const stage = stages[i];
            if (stage instanceof Pipeline) {
                continue;
            }
            let stage_source = {};
            // enumerate the required inputs of this stage
            let required_keys= stage.service._serviceio.required_input_fields
            let require_one_of_choices = stage.service._serviceio.require_one_of_choices
            if ( require_one_of_choices ) {
                if ( require_one_of_choices.length > 0) {
                    for (let j=0; j&lt;require_one_of_choices.length > 0; j++) {
                        required_keys.push(require_one_of_choices[j][0]);
                    }
                }
            }
            
            // starting from the last output, check if the required input data is available
            // if not, get it from the user_input
            // if input is defined, use its definition
            for ( let required_key of required_keys) {

                if (stage.source[required_key] != "default") { 
                    stage_source[required_key] = stage.source[required_key];
                    continue;
                }

                let found_input = false;
                for (let j=i-1; j>=0; j--) {
                    let stage_for_output = stages[j];
                    let stage_for_output_output_fields = stage_for_output.service._serviceio.output_structure;
                    if (required_key in stage_for_output_output_fields) {
                        stage_source[required_key] = {
                            source: stage_for_output.name,
                            field: required_key
                        }
                        found_input = true;
                    }
                    // special considerations
                    else if (required_key == "context" &amp;&amp; "text" in stage_for_output_output_fields) {
                        stage_source.context = {
                            source: stage_for_output.name,
                            field: "text"
                        };
                        found_input = true;
                    }
                    else if (required_key == "document_text" &amp;&amp; "text" in stage_for_output_output_fields) {
                        stage_source.document_text = {
                            source: stage_for_output.name,
                            field: "text"
                        };
                        found_input = true;
                    }
                    else if (required_key == "document_ids" &amp;&amp; "document_id" in stage_for_output_output_fields) {
                        stage_source.document_ids = {
                            source: stage_for_output.name,
                            field: "document_id",
                            pre_process: put_doc_id_to_array
                        };
                        found_input = true;
                    }
                }

                if (!found_input) {
                    if (required_key in user_input) {
                        stage_source[required_key] = user_input[required_key];
                        stage_source[required_key] = {
                            source: "user_input",
                            field: required_key
                        };
                    } else {
                        throw new ReferenceError(`Please add ${required_key} to user_input. The previous Nodes' outputs do not provide this data.`);
                    }
                }
            }
            let defaulted_stage = new Node(stage.name, stage.service, stage_source);
            defaulted_stages.push(defaulted_stage);
        }
        return defaulted_stages;
    }

    /**
     * Discontinue the execution of remaining nodes in the pipeline run
     * @param {string} termination_code 
     */
    async terminate(termination_code) {
        if (termination_code) {
            this._termination_codes.push(this.apiKey + termination_code);
        return {"message": `Request to terminate job "${termination_code}" received.`}
        }
        return {"message": `Request to terminate job is not valid (execution code missing).`}
    }
}

export {Pipeline}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AmbiguityDetectionService.html">AmbiguityDetectionService</a></li><li><a href="AnswerScoringService.html">AnswerScoringService</a></li><li><a href="ContradictionDetectionService.html">ContradictionDetectionService</a></li><li><a href="DocumentsDeleteService.html">DocumentsDeleteService</a></li><li><a href="DocumentsIngestService.html">DocumentsIngestService</a></li><li><a href="DocumentsSearchService.html">DocumentsSearchService</a></li><li><a href="EmailAnalysisService.html">EmailAnalysisService</a></li><li><a href="EmotionDetectionService.html">EmotionDetectionService</a></li><li><a href="FileConverterService.html">FileConverterService</a></li><li><a href="LanguageDetectionService.html">LanguageDetectionService</a></li><li><a href="LetsDiscussCreateService.html">LetsDiscussCreateService</a></li><li><a href="LetsDiscussDeleteService.html">LetsDiscussDeleteService</a></li><li><a href="LetsDiscussRetrieveService.html">LetsDiscussRetrieveService</a></li><li><a href="LetsDiscussService.html">LetsDiscussService</a></li><li><a href="LogicalErrorDetectionService.html">LogicalErrorDetectionService</a></li><li><a href="MicrolessonService.html">MicrolessonService</a></li><li><a href="NamedEntityRecognitionService.html">NamedEntityRecognitionService</a></li><li><a href="Node.html">Node</a></li><li><a href="ParaphraseService.html">ParaphraseService</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="ProfanityService.html">ProfanityService</a></li><li><a href="QuestionAndAnswerGenerationService.html">QuestionAndAnswerGenerationService</a></li><li><a href="QuestionAnsweringService.html">QuestionAnsweringService</a></li><li><a href="ReviewTaggerService.html">ReviewTaggerService</a></li><li><a href="SentimentAnalysisService.html">SentimentAnalysisService</a></li><li><a href="SimplifyService.html">SimplifyService</a></li><li><a href="SoffosAIService.html">SoffosAIService</a></li><li><a href="SoffosNodes.AmbiguityDetectionNode.html">AmbiguityDetectionNode</a></li><li><a href="SoffosNodes.AnswerScoringNode.html">AnswerScoringNode</a></li><li><a href="SoffosNodes.ContradictionDetectionNode.html">ContradictionDetectionNode</a></li><li><a href="SoffosNodes.DocumentsDeleteNode.html">DocumentsDeleteNode</a></li><li><a href="SoffosNodes.DocumentsIngestNode.html">DocumentsIngestNode</a></li><li><a href="SoffosNodes.DocumentsSearchNode.html">DocumentsSearchNode</a></li><li><a href="SoffosNodes.EmailAnalysisNode.html">EmailAnalysisNode</a></li><li><a href="SoffosNodes.EmotionDetectionNode.html">EmotionDetectionNode</a></li><li><a href="SoffosNodes.FileConverterNode.html">FileConverterNode</a></li><li><a href="SoffosNodes.LanguageDetectionNode.html">LanguageDetectionNode</a></li><li><a href="SoffosNodes.LetsDiscussCreateNode.html">LetsDiscussCreateNode</a></li><li><a href="SoffosNodes.LetsDiscussDeleteNode.html">LetsDiscussDeleteNode</a></li><li><a href="SoffosNodes.LetsDiscussNode.html">LetsDiscussNode</a></li><li><a href="SoffosNodes.LetsDiscussRetrieveNode.html">LetsDiscussRetrieveNode</a></li><li><a href="SoffosNodes.LogicalErrorDetectionNode.html">LogicalErrorDetectionNode</a></li><li><a href="SoffosNodes.MicrolessonNode.html">MicrolessonNode</a></li><li><a href="SoffosNodes.NamedEntityRecognitionNode.html">NamedEntityRecognitionNode</a></li><li><a href="SoffosNodes.ParaphraseNode.html">ParaphraseNode</a></li><li><a href="SoffosNodes.ProfanityNode.html">ProfanityNode</a></li><li><a href="SoffosNodes.QuestionAndAnswerGenerationNode.html">QuestionAndAnswerGenerationNode</a></li><li><a href="SoffosNodes.QuestionAnsweringNode.html">QuestionAnsweringNode</a></li><li><a href="SoffosNodes.ReviewTaggerNode.html">ReviewTaggerNode</a></li><li><a href="SoffosNodes.SentimentAnalysisNode.html">SentimentAnalysisNode</a></li><li><a href="SoffosNodes.SimplifyNode.html">SimplifyNode</a></li><li><a href="SoffosNodes.SummarizationNode.html">SummarizationNode</a></li><li><a href="SoffosNodes.TableGeneratorNode.html">TableGeneratorNode</a></li><li><a href="SoffosNodes.TagGenerationNode.html">TagGenerationNode</a></li><li><a href="SoffosNodes.TranscriptCorrectionIO.html">TranscriptCorrectionIO</a></li><li><a href="SoffosPipelines.AskADocumentPipeline.html">AskADocumentPipeline</a></li><li><a href="SoffosPipelines.FileIngestPipeline.html">FileIngestPipeline</a></li><li><a href="SummarizationService.html">SummarizationService</a></li><li><a href="TableGeneratorService.html">TableGeneratorService</a></li><li><a href="TagGenerationService.html">TagGenerationService</a></li><li><a href="TranscriptCorrectionService.html">TranscriptCorrectionService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#formatUuid">formatUuid</a></li><li><a href="global.html#getContent">getContent</a></li><li><a href="global.html#isValidUuid">isValidUuid</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Sep 07 2023 18:26:54 GMT+0800 (Singapore Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
